// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

RWTexture2D<float4> Result;

Texture2D<float4> ScrapeMask;
SamplerState samplerScrapeMask; // this is automatically declared when the texture is set

Texture2D<float4> ScrapeEdgeMask;
SamplerState samplerScrapeEdgeMask; // this is automatically declared when the texture is set

// variables
int2 resolution;
float scrapeSize;
float clearStrength;
float iceRegrowth;
float iceRegrowthNeighbourFactor;
float iceRegrowthNeighbourThreshold;
float maxIceRegrowthNeighbourFactor;

// active input
float2 scrapeUV;
bool scraping;

float deltaTime;

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float clear = 1.0f;
    
    if (scraping == false)
        clear = 0.0f;
        

    float mx = max(resolution.x, resolution.y);
    float2 uv_mx = id.xy / mx;
    float2 scrape_uv_mx = (scrapeUV * resolution) / mx;



    float2 scrapeMaskUV = (uv_mx + (scrapeSize / 2.0f) - scrape_uv_mx) / scrapeSize;
    if (scrapeMaskUV.x > 1.0f || scrapeMaskUV.x < 0.0f || scrapeMaskUV.y > 1.0f || scrapeMaskUV.y < 0.0f)
        clear = 0.0f;

    float currentIce = Result[id.xy].w;
    float4 s = ScrapeMask.SampleLevel(samplerScrapeMask, scrapeMaskUV, 0);
    
    float currentIceRegrowth = iceRegrowth;
    
    int2 coord = int2(id.xy);
    
    int2 rightNeighbour  = coord + int2(1, 1);
    int2 leftNeighbour   = coord + int2(-1, 1);
    int2 topNeighbour    = coord + int2(1, -1);
    int2 bottomNeighbour = coord + int2(-1, -1);
    
    // int2 rightNeighbour  = coord + int2(1, 0);
    // int2 leftNeighbour   = coord + int2(-1, 0);
    // int2 topNeighbour    = coord + int2(0, 1);
    // int2 bottomNeighbour = coord + int2(0, -1);
    
    rightNeighbour  = clamp(rightNeighbour,  0, resolution - 1);
    leftNeighbour   = clamp(leftNeighbour,   0, resolution - 1);
    topNeighbour    = clamp(topNeighbour,    0, resolution - 1);
    bottomNeighbour = clamp(bottomNeighbour, 0, resolution - 1);
    
    if (Result[rightNeighbour].w > iceRegrowthNeighbourThreshold)
        currentIceRegrowth += iceRegrowthNeighbourFactor;
    
    if (Result[leftNeighbour].w > iceRegrowthNeighbourThreshold)
        currentIceRegrowth += iceRegrowthNeighbourFactor;
    
    if (Result[topNeighbour].w > iceRegrowthNeighbourThreshold)
        currentIceRegrowth += iceRegrowthNeighbourFactor;
    
    if (Result[bottomNeighbour].w > iceRegrowthNeighbourThreshold)
        currentIceRegrowth += iceRegrowthNeighbourFactor;
    
    if (currentIceRegrowth > maxIceRegrowthNeighbourFactor)
        currentIceRegrowth = maxIceRegrowthNeighbourFactor;
    
    if (currentIce < 1.0f)
        currentIce += currentIceRegrowth * deltaTime; 
    
    currentIce -= clear * s * clearStrength;




    // ----- Edge Calculation ----- //

    float currentEdge = Result[id.xy];
    
    float4 e = ScrapeEdgeMask.SampleLevel(samplerScrapeEdgeMask, scrapeMaskUV, 0);

    currentEdge += clear * s * clearStrength;
    if (currentIce > 0.8f)
    currentEdge -= clear * e * clearStrength * 4;

    if (currentEdge < 1.0f)
        currentEdge += currentIceRegrowth * 0.25f * deltaTime;

    // ----- write results ----- //
    float4 currentColor = Result[id.xy];
    Result[id.xy] = float4(currentEdge, currentColor.y, currentColor.z, currentIce);
}
